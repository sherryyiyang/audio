<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audio Room</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #1a1a2e;
      color: #eee;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    .container { text-align: center; padding: 2rem; }

    #status {
      font-size: 1.1rem;
      margin-bottom: 2rem;
    }
    .dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 0.4rem;
      vertical-align: middle;
    }
    .dot.green { background: #2ecc71; }
    .dot.yellow { background: #f39c12; }
    .dot.red { background: #e94560; }

    #mute-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: none;
      background: #2ecc71;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto;
    }
    #mute-btn:hover { transform: scale(1.05); }
    #mute-btn.muted { background: #e94560; }
    #mute-btn svg { width: 36px; height: 36px; }

    #mute-label {
      margin-top: 0.6rem;
      font-size: 0.85rem;
      color: #888;
    }

    #user-count {
      margin-bottom: 0.5rem;
      font-size: 0.8rem;
      color: #555;
    }

    #reset-btn {
      margin-top: 2rem;
      padding: 0.5rem 1.2rem;
      border: 1px solid #555;
      border-radius: 0.5rem;
      background: transparent;
      color: #888;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    #reset-btn:hover { border-color: #e94560; color: #e94560; }
  </style>
</head>
<body>
  <div class="container">
    <div id="user-count">0/2 online</div>
    <p id="status"><span class="dot yellow"></span> Joining room...</p>
    <button id="mute-btn">
      <svg id="mic-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor"
           stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
        <line x1="12" y1="19" x2="12" y2="23"/>
        <line x1="8" y1="23" x2="16" y2="23"/>
      </svg>
    </button>
    <div id="mute-label">Mic on</div>
    <button id="reset-btn">Reset Room</button>
  </div>
  <audio id="remote-audio" autoplay></audio>

  <script>
    const statusEl = document.getElementById("status");
    const userCountEl = document.getElementById("user-count");
    const muteBtn = document.getElementById("mute-btn");
    const muteLabel = document.getElementById("mute-label");
    const remoteAudio = document.getElementById("remote-audio");

    let ws;
    let pc;
    let localStream;
    let muted = false;
    let pendingCandidates = [];

    // --- Mic ---
    async function getMic() {
      if (localStream) return localStream;
      localStream = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false },
        video: false,
      });
      return localStream;
    }

    // --- WebRTC ---
    function createPC() {
      pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      });
      pc.onicecandidate = (e) => {
        if (e.candidate) send({ type: "ice-candidate", candidate: e.candidate });
      };
      pc.ontrack = (e) => { remoteAudio.srcObject = e.streams[0]; };
      pc.onconnectionstatechange = () => {
        if (pc.connectionState === "connected") {
          setStatus("green", "Connected");
        }
        if (pc.connectionState === "disconnected" || pc.connectionState === "failed") {
          cleanupPC();
          setStatus("yellow", "Waiting for the other person...");
        }
      };
    }

    async function startCall() {
      createPC();
      const stream = await getMic();
      for (const track of stream.getTracks()) pc.addTrack(track, stream);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      send(pc.localDescription);
    }

    async function handleOffer(offer) {
      createPC();
      const stream = await getMic();
      for (const track of stream.getTracks()) pc.addTrack(track, stream);
      await pc.setRemoteDescription(offer);
      for (const c of pendingCandidates) await pc.addIceCandidate(c);
      pendingCandidates = [];
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      send(pc.localDescription);
    }

    function cleanupPC() {
      if (pc) { pc.close(); pc = null; }
      remoteAudio.srcObject = null;
      pendingCandidates = [];
    }

    // --- WebSocket ---
    function send(msg) {
      if (ws && ws.readyState === 1) ws.send(JSON.stringify(msg));
    }

    let reconnectDelay = 1000;

    function connect() {
      const proto = location.protocol === "https:" ? "wss" : "ws";
      ws = new WebSocket(`${proto}://${location.host}`);

      ws.onopen = () => {
        reconnectDelay = 1000; // reset on success
        setStatus("yellow", "Waiting for the other person...");
      };

      ws.onerror = (e) => {
        console.error("WebSocket error:", e);
      };

      ws.onmessage = async (e) => {
        let msg;
        try { msg = JSON.parse(e.data); } catch { return; }

        if (msg.type === "full") {
          userCountEl.textContent = "2/2 online";
          setStatus("red", "Room is full — try again later or hit Reset");
          return;
        }

        if (msg.type === "count") {
          userCountEl.textContent = `${msg.count}/2 online`;
          if (msg.count < 2) {
            cleanupPC();
            setStatus("yellow", "Waiting for the other person...");
          }
        }

        if (msg.type === "start-call" && !pc) {
          setStatus("yellow", "Connecting...");
          startCall();
        }

        if (msg.type === "offer") await handleOffer(msg);

        if (msg.type === "answer" && pc) {
          await pc.setRemoteDescription(msg);
          for (const c of pendingCandidates) await pc.addIceCandidate(c);
          pendingCandidates = [];
        }

        if (msg.type === "ice-candidate" && msg.candidate) {
          if (pc && pc.remoteDescription) {
            await pc.addIceCandidate(msg.candidate);
          } else {
            pendingCandidates.push(msg.candidate);
          }
        }
      };

      ws.onclose = () => {
        cleanupPC();
        setStatus("red", `Disconnected — retrying in ${reconnectDelay / 1000}s...`);
        setTimeout(connect, reconnectDelay);
        reconnectDelay = Math.min(reconnectDelay * 2, 10000); // backoff up to 10s
      };
    }

    // --- UI ---
    function setStatus(color, text) {
      statusEl.innerHTML = `<span class="dot ${color}"></span> ${text}`;
    }

    muteBtn.addEventListener("click", () => {
      if (!localStream) return;
      muted = !muted;
      localStream.getAudioTracks().forEach((t) => { t.enabled = !muted; });
      muteBtn.classList.toggle("muted", muted);
      muteLabel.textContent = muted ? "Mic off" : "Mic on";
    });

    // --- Reset button ---
    document.getElementById("reset-btn").addEventListener("click", () => {
      send({ type: "reset" });
      cleanupPC();
      if (ws) { ws.close(); ws = null; }
      setStatus("yellow", "Room reset — rejoining...");
      setTimeout(() => getMic().then(() => connect()), 1000);
    });

    // --- Start immediately ---
    getMic().then(() => connect());
  </script>
</body>
</html>
